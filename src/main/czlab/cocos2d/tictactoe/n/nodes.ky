
(ns ^{:doc ""
      :author "Kenneth Leung"}
  czlab.cocos2d.nodes

  (:require ["../ccsx" :as cx]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const BD_SZ 3)
(const GD_SZ (* BD_SZ BD_SZ))
;typedef s_arr<int, GD_SZ> ArrCells;
;typedef s_arr<int, BD_SZ> ArrDim;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createGrid
  "Stores the grid values and the set of winning goals"
  [seed]
  (atom
    {:typeId ::Grid
     :vals (slice seed)
     :goals (mapGoalSpace) }))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createPlayer "" [category value id]
  (atom {:typeId ::Player
         :value value
         :pidlong ""
         :color ""
         :pid ""
         :category category :pnum id}))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn copyPlayer "" [otherPlayer]
  (atom (merge {} @otherPlayer)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createPlayers "" []
  (atom {:typeId ::Players :parr []}))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createSquare "" [cell]
  (atom {:cell cell :png "z" :value 0
         :pix (new cc.Sprite "#z.png")}))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn toggleSquare "" [square cfg nv]
  (var x (k/get-in @cfg [:csts :CV_X])
       o (k/get-in @cfg [:csts :CV_O]))
  (var~ png)
  (when (zero? (get @square :value))
    (set! png
          (cond (= nv x) "x"
                (= nv o) "o" :else "z"))
    (swap! sqaure
           (fn [m]
             (assoc! m :value nv :png png)
             (.setSpriteFrame (get m :pix)
                              (str "#" png ".png")) m))) square)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn flipSquare "" [square]
  (var {:keys [png pix value]} @square)
  (if (not= value 0)
    (.setSpriteFrame pix (str png ".i.png"))) square)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createSquares "" []
  (atom {:typeId ::CSquares :boxes [] :sqs[]}))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createCellPos "" []
  (atom {:typeId ::CellPos :cell -1 :px -1 :py -1}))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createGVars "" []
  (atom {:typeId ::GVars :pnum 0 :lastWinner 0}))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;EOF

(defn mapGridPos "" [scale]

  "Calculate position of each individual cells in the grid,
  so that we can detect when a user clicks on the cell
  memorize the co-ordinates of each cell on the board, so
  we know which cell the user has clicked on"

  (var csz (cx/scaleSize (cx/calcSize "z.png") scale)
       ro (* (/ 8.0 72.0) scale)
       boxes (map #(do {}) (range GD_SZ))
       gh (* ro csz.height)
       gw (* ro csz.width)
       zh (+ (* gh (-1 BD_SZ))
             (* BD_SZ csz.height))
       zw (+ (* gw (-1 BD_SZ))
             (* BD_SZ csz.width))
       wb (cx/visBox)
       x0 (- wb.cx (HTV zw))
       y0 (+ wb.cy (HTV zh))
       x1 x0
       y1 y0)
  (var~ x2 y2)
  (for [r 0 :while (< r BD_SZ) :recur (+1 r)]
    (for [c 0 :while (< c BD_SZ) :recur (+1 c)]
      (set! y2 (- y1 csz.height)
            x2 (+ x1 csz.width))
      (set-in! boxes
               (+ c (* r BD_SZ))
               {:top y1 :right x2 :bottom y2 :left x1})
      (set! x1 (+ x2 gw)))
    (set! y1 (- y2 gh) x1 x0))
  boxes)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn mapGoalSpace "" []
  (var goals []
       r3 (range BD_SZ)
       dx (map #({}) r3)
       dy (map #({}) r3))
  (var~ h v)
  (for [r 0 :while (< r BD_SZ) :recur (+1 r)]
    (set! h (map #({}) r3)
          v (map #({}) r3))
    (for [c 0 :while (< c BD_SZ) :recur (+1 c)]
      (set-in! h c (+ c (* r BD_SZ)))
      (set-in! v c (+ r (* c BD_SZ))))
    (conj! goals h v)
    (set-in! dx r (+ r (* r BD_S)))
    (set-in! dy r (+ r (* BD_SZ (- BD_SZ r 1)))))
  (conj! goals dx dy))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn fmtGameData "" [mode]
  (cond
    (= mode *GMode-TWO*)
    {:ppids {:p1 [1 "player1"] :p2 [2 "player2"] } :pnum 1 }
    (= mode *GMode-ONE*)
    {:ppids {:cpu [2 "computer"] :p1 [1 "player1"] }  :pnum 1}
    (= mode *GMode-NET*)
    {:ppids {} :pnum 0}
    :else
    (trap! "bad game mode!")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;EOF
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- not-any? "" [arr v]
  (not (some #(if (= v %) #t #f) arr)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- every? "" [arr v] (not (not-any? arr v)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createTTToe "" [p1v p2v]
  (atom {:actors [0 p1v p2v]
         :goals (mapGoalSpace)}))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn isNought? "" [cellv] (= 0 cellv))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn tttFirstMove
  "If brand new game, just make a random move"
  [ttt]
  (var {:keys [grid]} @ttt sz (n# grid))
  (if (and (pos? sz)
           (every? grid 0)) (cx/randInt sz) -1))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn tttSyncState "" [ttt seed actor]
  (swap! ttt
         (fn [m]
           (k/copyVector seed (get m :grid))
           (set-in! (get m :actors) 0 actor) m)))

//////////////////////////////////////////////////////////////////////////////
// find set of empty slots
(defn tttNextMoves "" [ttt snapshot]
  (var {:keys [state]} @snapshot ret [])
  (each (fn [v pos]
          (if (isNought? v) (conj! ret pos))) state) ret)

//////////////////////////////////////////////////////////////////////////////
//
void TTToe::undoMove(not_null<ag::FFrame<BD_SZ>*> snap, int move) {
  assert(move >= 0 && move < snap->_state.size());
  snap->_state[move] = _nil;
}

//////////////////////////////////////////////////////////////////////////////
//
void TTToe::makeMove(not_null<ag::FFrame<BD_SZ>*> snap, int move) {
  assert(move >= 0 && move < snap->_state.size());
  if (isNil(snap->_state[move])) {
    snap->_state[move] = snap->_cur;
  } else {
    throw "cell [" + FTOS(move) + "] is not free";
  }
}

//////////////////////////////////////////////////////////////////////////////
//
void TTToe::switchPlayer(not_null<ag::FFrame<BD_SZ>*> snap) {
  auto t = snap->_cur;
  snap->_cur= snap->_other;
  snap->_other=t;
}

//////////////////////////////////////////////////////////////////////////////
//
int TTToe::getOtherPlayer(int pv) {
  if (pv == _actors[1]) {
    return _actors[2];
  }

  if (pv == _actors[2]) {
    return _actors[1];
  }

  return _nil;
}

//////////////////////////////////////////////////////////////////////////////
//
owner<ag::FFrame<BD_SZ>*>  TTToe::takeFFrame() {
  auto ff = mc_new( ag::FFrame<BD_SZ> );

  ff->_other= getOtherPlayer(_actors[0]);
  ff->_cur= _actors[0];
  ff->_lastBestMove= -1;
  S__COPY(_grid, ff->_state);

  return ff;
}

//////////////////////////////////////////////////////////////////////////////
//
int TTToe::evalScore(not_null<ag::FFrame<BD_SZ>*> snap) {
  // if we lose, return a nega value
  F__LOOP(it, _GOALS) {
    auto &t= *it;
    if (testWin(snap->_state, snap->_other, t)) {
      return -100;
    }
  }
  return 0;
}

//////////////////////////////////////////////////////////////////////////////
//
bool TTToe::isOver(not_null<ag::FFrame<BD_SZ>*> snap) {

  F__LOOP(it, _GOALS) {
    auto &t = *it;
    if (testWin(snap->_state, snap->_other, t) ||
        testWin(snap->_state, snap->_cur, t)) {
      return true;
    }
  }
  return isStalemate(snap);
}

//////////////////////////////////////////////////////////////////////////////
//
bool TTToe::isStalemate(not_null<ag::FFrame<BD_SZ>*> snap) {
  return not_any(snap->_state, _nil);
}

//////////////////////////////////////////////////////////////////////////////
//
int TTToe::getWinner(not_null<ag::FFrame<BD_SZ>*> snap, ArrDim &combo) {

  int win= -1;
  F__LOOP(it, _GOALS) {
    auto &t= *it;
    if (testWin(snap->_state, snap->_other, t)) {
      win=snap->_other;
    }
    else
    if (testWin(snap->_state, snap->_cur, t)) {
      win=snap->_cur;
    }
    if (win > 0) {
      S__COPY(t,combo);
      break;
    }
  }
  return win;
}

//////////////////////////////////////////////////////////////////////////////
//
bool TTToe::testWin(const ArrCells &vs, int actor, const ArrDim &g) {

  auto cnt=g.size();
  for (auto n= 0; n < g.size(); ++n) {
    if (actor == vs[g[n]]) {
      --cnt;
    }
  }
  return cnt == 0;
}



NS_END



